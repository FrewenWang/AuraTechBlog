---
title: 多叉树的相关算法的学习与实现
date: 2018-11-21 23:59:35
tags: [算法,多叉树]
---

# 多叉树的相关算法的学习与实现

在我们的编程的算法的中经常会用到多叉树，很简单，比如Android上的View布局就是一个最典型的View多叉树。我们通过下面这项相关算法我们可以更好的理解多叉树的设计与实现，对于Android中很多的View操作可以有更加深入的认识。

多叉树的数据结构：

```
package com.frewen.algorithm.demo.tree;

import java.util.ArrayList;
import java.util.List;

/**
 * 多叉树的节点
 */
public class MultiTreeNode<Value> {
    /**
     * 多叉树的父节点的ID
     */
    private int parentId;
    /**
     * 多叉树的节点的ID
     */
    private int selfId;
    /**
     * 多叉树节点的名字
     */
    protected String nodeName;
    /**
     * 节点对象
     */
    protected Value obj;
    /**
     * 子节点的列表
     */
    protected List<MultiTreeNode> childList = new ArrayList<>();

    public MultiTreeNode(Value value) {
        this.obj = value;
    }

    public void addChild(MultiTreeNode node) {
        this.childList.add(node);
    }

    /**
     * 初始化多叉树的子节点
     * @return
     */
    public static MultiTreeNode<String> initChildList() {
        MultiTreeNode<String> H = new MultiTreeNode("H");
        MultiTreeNode<String> I = new MultiTreeNode("I");
        MultiTreeNode<String> J = new MultiTreeNode("J");
        MultiTreeNode<String> E = new MultiTreeNode("E");
        E.addChild(H);
        E.addChild(I);
        E.addChild(J);


        MultiTreeNode<String> F = new MultiTreeNode("F");
        MultiTreeNode<String> G = new MultiTreeNode("G");

        MultiTreeNode<String> B = new MultiTreeNode("B");
        MultiTreeNode<String> C = new MultiTreeNode("C");
        MultiTreeNode<String> D = new MultiTreeNode("D");

        B.addChild(E);
        B.addChild(F);
        D.addChild(G);


        MultiTreeNode<String> A = new MultiTreeNode("A");
        A.addChild(B);
        A.addChild(C);
        A.addChild(D);

        return A;

    }

    public List<MultiTreeNode> getChildren() {
        return this.childList;
    }
}

```


### 多叉树的遍历

我们知道树的遍历，我们就绕不开两种遍历方式：递归遍历、非递归遍历。

下面我们先看一下递归遍历：

```
 /**
     * 多叉树的递归遍历。
     * 多叉树的递归遍历：先打印根节点的值，然后依次遍历所有的子节点。持续递归。
     *
     * 我们可以思考一个问题：
     * 使用递归遍历的优点：
     * 1、递归遍历代码实现比较简单
     *
     * 使用递归遍历的缺点：
     * 1、递归遍历实现不太便于理解。
     * 2、递归遍历需要递归入栈，如果树的结构特别复杂，特别深。那么我们递归的算法递归
     *      就会在当前线程的栈中不断的入栈,入的多了就爆了,就会抛出java.lang.StackOverflowError
     *      这种情况在尤其在我们误入递归死循环之后肯定会出现，相信大家都遇到过。
     * @param root
     */
    private static void recursionTraversal(MultiTreeNode<String> root) {
        if (null == root) {
            return;
        }
        System.out.print(root.obj + "、");
        for (MultiTreeNode treeNode : root.getChildren()) {
            recursionTraversal(treeNode);
        }

    }
```



非递归遍历。非递归遍历中，我们又可以使用广度优先算法、或者是深度优先算法。


```
 /**
     * 多叉树的广度优先算法（非递归方式的遍历）
     * @param root
     */
    private static void breadthFirstTraversal(MultiTreeNode<String> root) {
        // 广度优先需要构建一个先进先出的队列
        Deque<MultiTreeNode> nodeDeque = new LinkedList<>();
        // 构建一个多叉树的引用，指向多叉树的Root
        MultiTreeNode<String> node = root;
        // 让根节点入队列
        nodeDeque.push(node);
        // 判断队列不为空，进行出队列的管理。所有广度遍历的节点依次入队列。
        // 待队列中所有元素均出队列之后，那么也表明多叉树的遍历结束
        while (!nodeDeque.isEmpty()) {
            // 判断出队列的node节点。第一个出来的Node节点的是根节点。
            node = nodeDeque.pop();
            System.out.print(node.obj + "、");
            // 因为是广度优先，所以先遍历根节点的所有的元素，然后将所有元素依次入队列
            // 然后这样，相当于一次广度遍历
            for (MultiTreeNode treeNode : node.getChildren()) {
                nodeDeque.addLast(treeNode);
            }
        }
    }
```



```
/**
     * 多叉树的深度优先算法（非递归方式的遍历）
     * 深度优先需要构建一个后进先出的栈,
     * @param root
     */
    private static void depthFirstTraversal(MultiTreeNode<String> root) {
        // 深度优先需要构建一个后进先出的栈,
        Stack<MultiTreeNode> stack = new Stack<>();
        // 构建一个多叉树的引用，指向多叉树的Root
        MultiTreeNode<String> node = root;

        // 让根节点入栈
        stack.push(node);
        // 判断栈是否为空，然后执行出栈的操作。
        while (!stack.isEmpty()) {
            node = stack.pop();
            System.out.print(node.obj + "、");
            // 因为是深度优先遍历，所以我们要先出栈根节点，然后，遍历根节点的所有子节点
            // 将子节点依次入栈。这样我们就可以将最终的叶子节点位于栈顶。
            // 然后我们依次执行出栈遍历的操作
            List<MultiTreeNode> children = node.getChildren();
            if (children != null && children.size() > 0) {
                // 这个我们故意从最后节点开始遍历，比较符合咱们的遍历习惯
                for (int i = children.size() - 1; i >= 0; i--) {
                    stack.push(children.get(i));
                }
            }
        }
    }
```


有时候，我们也需要计算多叉树的深度，多叉树的深度，通常我们是使用递归算法，具体实现见下方：


```
/**
     * 计算多叉树的深度
     * 树（多叉树、二叉树）的深度计算一般都是用递归计算
     * 具体可以看多叉树的递归遍历算法
     * @param root
     * @return
     */
    private static int maxDepth(MultiTreeNode<String> root) {
        if (root == null) {
            return 0;
        }
        if (root.getChildren() == null || root.getChildren().isEmpty()) {
            return 1;
        }
        int maxDepth = 0;
        // 我们这个可以很好理解：
        // 每当我们遍历一层子节点，我们的树的深度就会增加1。
        // 直到递归遍历到最后的子节点位置。我们取这个子节点的最大的深度
        // 我们就取这个子节点中最大的深度位置
        for (MultiTreeNode node : root.getChildren()) {
            int depth = maxDepth(node) + 1;
            if (maxDepth < depth) {
                maxDepth = depth;
            }
        }
        return maxDepth;
    }
```

在Android中有很多多叉树的应用，最明显的就是Activity中的findViewById.顺便我们来学习一下这个方法，看他是使用咱们上面的哪个算法来计算View的查找的。


```
 @Nullable
    public <T extends View> T findViewById(@IdRes int id) {
        return getWindow().findViewById(id);
    }
```


```
/**
     * 我们通过查看可以发现，其实所有的findViewById的方法，归根结底都是调用的View中findViewById
     * @param id
     * @param <T>
     * @return
     */
    @Nullable
    public final <T extends View> T findViewById(@IdRes int id) {
        if (id == NO_ID) {
            return null;
        }
        return findViewTraversal(id);
    }
```

那么很显然，我们来查看一下：findViewTraversal(id)这个方法

```
/**
     * 如果ID等于VIew本身的ID。则返回VIew本身。否则返回null
     * @param id
     * @param <T>
     * @return
     */
    protected <T extends View> T findViewTraversal(@IdRes int id) {
        if (id == mID) {
            return (T) this;
        }
        return null;
    }
```
额，郁闷了。说好的树查找呢！！！

别着急，我们在树的遍历中，既然需要查找。那么一般就是在VIewGroup中进行子View(树的子节点)的查找。我们来看一下ViewGroup中的实现：

```
@Override
    protected <T extends View> T findViewTraversal(@IdRes int id) {
        // 如果ID等于当前ViewGroup的ID。则直接返回此ViewGroup
        if (id == mID) {
            return (T) this;
        }
        // 获取当前ViewGroup的所有子View(此节点下的所有子节点)
        final View[] where = mChildren;
        final int len = mChildrenCount;
        // 进行子VIew的遍历
        for (int i = 0; i < len; i++) {
            View v = where[i];
            // 然后执行ViewGroup的中的子View的ID。
            // 我们可以分析如果这个ViewGroup的都是View的话。则直接判断ID即可。
            // 如果是ViewGroup的话，则我们在递归子ViewGroup的子View.依次类推。知道找到对应View
            // 从这里面我们可以看出findViewById是一个深度优先的递归查找算法
            if ((v.mPrivateFlags & PFLAG_IS_ROOT_NAMESPACE) == 0) {
                v = v.findViewById(id);

                if (v != null) {
                    return (T) v;
                }
            }
        }

        return null;
    }
```
我们在VIewGroup中执行查找ViewGroup中的子View的ID。我们可以分析如果这个ViewGroup的都是View的话。则直接判断ID即可。如果是ViewGroup的话，则我们在递归子ViewGroup的子View.依次类推。知道找到对应View，从这里面我们可以看出findViewById是一个深度优先的递归查找算法